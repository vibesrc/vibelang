// std.collections - Collection types

use std.mem.{alloc, resize, dealloc}

/// Vec<T> - heap-allocated, growable vector
pub struct Vec<T> {
    ptr: *T
    len: i64
    capacity: i64
}

impl Vec<T> {
    pub fn new() -> Vec<T> {
        return Vec<T> {
            ptr: ptr_null<T>(),
            len: 0,
            capacity: 0
        }
    }

    pub fn with_capacity(cap: i64) -> Vec<T> {
        let ptr = alloc(cap * sizeof<T>()) as *T
        return Vec<T> {
            ptr: ptr,
            len: 0,
            capacity: cap
        }
    }

    pub fn len(&self) -> i64 {
        return self.len
    }

    pub fn is_empty(&self) -> bool {
        return self.len == 0
    }

    pub fn capacity(&self) -> i64 {
        return self.capacity
    }

    pub fn push(~self, value: T) {
        if self.len == self.capacity {
            self.grow()
        }
        unsafe {
            let dest = ptr_add<T>(self.ptr, self.len)
            ptr_write<T>(dest, value)
        }
        self.len = self.len + 1
    }

    pub fn pop(~self) -> Option<T> {
        if self.len == 0 {
            return Option<T>.None
        }
        self.len = self.len - 1
        unsafe {
            let src = ptr_add<T>(self.ptr, self.len)
            let value = ptr_read<T>(src)
            return Option<T>.Some(value)
        }
    }

    pub fn get(&self, index: i64) -> Option<T> {
        if index < 0 or index >= self.len {
            return Option<T>.None
        }
        unsafe {
            let src = ptr_add<T>(self.ptr, index)
            return Option<T>.Some(ptr_read<T>(src))
        }
    }

    pub fn set(~self, index: i64, value: T) {
        if index < 0 or index >= self.len {
            panic("Vec index out of bounds")
        }
        unsafe {
            let dest = ptr_add<T>(self.ptr, index)
            ptr_write<T>(dest, value)
        }
    }

    pub fn clear(~self) {
        self.len = 0
    }

    fn grow(~self) {
        let new_cap = 4
        if self.capacity > 0 {
            new_cap = self.capacity * 2
        }
        // Use alloc for first allocation, resize for subsequent
        if self.capacity == 0 {
            self.ptr = alloc(new_cap * sizeof<T>()) as *T
        } else {
            self.ptr = resize(self.ptr as *u8, new_cap * sizeof<T>()) as *T
        }
        self.capacity = new_cap
    }

    pub fn free(~self) {
        if not ptr_is_null(self.ptr) {
            dealloc(self.ptr as *u8)
        }
        self.ptr = ptr_null<T>()
        self.len = 0
        self.capacity = 0
    }
}
