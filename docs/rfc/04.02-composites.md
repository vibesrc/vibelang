# Section 4.2: Composite Types

Composite types are built from other types. This section covers structs, enums, and how they interact with the ownership system.

## 4.2.1 Structs

Structs group related data together:

```vibelang
struct Point {
    x: f64
    y: f64
}

struct Person {
    name: String
    age: u32
}
```

### Struct Instantiation

```vibelang
let p = Point { x: 1.0, y: 2.0 }
let person = Person {
    name: String.from("Alice"),
    age: 30
}
```

### Field Access

```vibelang
let x = p.x                     // 1.0
let name = &person.name         // borrow field
```

### Struct Update Syntax

Create a new struct based on an existing one:

```vibelang
let p1 = Point { x: 1.0, y: 2.0 }
let p2 = Point { x: 3.0, ..p1 }  // y: 2.0 from p1
```

### Struct Ownership

A struct's ownership category depends on its fields:

```vibelang
// Copy struct (all fields are Copy)
struct Point {
    x: f64
    y: f64
}

let a = Point { x: 1.0, y: 2.0 }
let b = a                       // copies, both valid

// Owned struct (contains owned field)
struct Person {
    name: String                // String is owned
    age: u32
}

let a = Person { name: String.from("Alice"), age: 30 }
let b = a                       // moves, a is invalid
```

### Struct Methods

Methods are defined in `impl` blocks:

```vibelang
impl Point {
    // Associated function (no self)
    fn new(x: f64, y: f64) -> Point {
        return Point { x: x, y: y }
    }
    
    // Method (takes self by reference, read-only)
    fn distance(self: &Point, other: &Point) -> f64 {
        const dx = self.x - other.x
        const dy = self.y - other.y
        return sqrt(dx * dx + dy * dy)
    }
    
    // Method (mutable borrow, can mutate in place)
    fn scale(self: ~Point, factor: f64) {
        self.x *= factor
        self.y *= factor
    }
    
    // Method (takes self by value, consumes)
    fn into_tuple(self: Point) -> (f64, f64) {
        return (self.x, self.y)
    }
}

// Usage
let p1 = Point.new(0.0, 0.0)
let p2 = Point.new(3.0, 4.0)
let d = p1.distance(&p2)        // 5.0
let tuple = p2.into_tuple()     // p2 is moved
```

### Self Parameter Conventions

| Signature | Meaning |
|-----------|---------|
| `self: &Self` | Borrow self (read-only) |
| `self: ~Self` | Borrow self (mutable) |
| `self: Self` | Take ownership of self |

## 4.2.2 Enums

Enums define types with variants:

```vibelang
enum Direction {
    North
    South
    East
    West
}

let dir = Direction.North
```

### Enums with Data

Variants can carry data:

```vibelang
enum Option<T> {
    Some(T)
    None
}

enum Result<T, E> {
    Ok(T)
    Err(E)
}

enum Token {
    Ident(String)
    Number(i64)
    Float(f64)
    LParen
    RParen
    Eof
}
```

### Enum Instantiation

```vibelang
let some = Option.Some(42)
let none: Option<i32> = Option.None
let ok: Result<i32, String> = Result.Ok(42)
let err: Result<i32, String> = Result.Err(String.from("oops"))
```

### Pattern Matching Enums

```vibelang
fn describe(dir: Direction) -> String {
    return match dir {
        Direction.North => String.from("up")
        Direction.South => String.from("down")
        Direction.East => String.from("right")
        Direction.West => String.from("left")
    }
}

fn unwrap_or<T>(opt: Option<T>, default: T) -> T {
    return match opt {
        Option.Some(value) => value
        Option.None => default
    }
}
```

### Enum Ownership

Like structs, enum ownership depends on variant contents:

```vibelang
// Copy enum (all variants are Copy or empty)
enum Direction {
    North
    South
    East
    West
}

let a = Direction.North
let b = a                       // copies

// Owned enum (has variant with owned data)
enum Token {
    Ident(String)               // String is owned
    Number(i64)
}

let a = Token.Ident(String.from("foo"))
let b = a                       // moves, a is invalid
```

### Enum Methods

```vibelang
impl Option<T> {
    fn is_some(self: &Option<T>) -> bool {
        return match self {
            Option.Some(_) => true
            Option.None => false
        }
    }
    
    fn unwrap(self: Option<T>) -> T {
        return match self {
            Option.Some(value) => value
            Option.None => panic("unwrap on None")
        }
    }
    
    fn map<U>(self: Option<T>, f: fn(T) -> U) -> Option<U> {
        return match self {
            Option.Some(value) => Option.Some(f(value))
            Option.None => Option.None
        }
    }
}
```

## 4.2.3 Tuples

Tuples are anonymous structs with numbered fields:

```vibelang
let pair: (i32, String) = (42, String.from("hello"))
let triple = (1, 2.0, true)

// Access by index
let first = pair.0              // 42
let second = &pair.1            // &String
```

### Tuple Destructuring

```vibelang
let (x, y) = (1, 2)
let (a, b, c) = triple
```

### Unit Tuple

The empty tuple `()` is equivalent to `void`:

```vibelang
fn returns_nothing() -> () {
    // ...
}
```

## 4.2.4 Slice Type

`Slice<T>` is a view into contiguous data:

```vibelang
struct Slice<T> {
    ptr: *T
    len: u64
}
```

### Creating Slices

```vibelang
// From fixed array
let arr: i32[5] = [1, 2, 3, 4, 5]
let slice: Slice<i32> = &arr            // whole array
let slice: Slice<i32> = &arr[1..4]      // elements 1, 2, 3

// From Array<T>
let vec = Array<i32>()
vec.push(1)
vec.push(2)
let slice: Slice<i32> = &vec

// From String
let s = String.from("hello")
let bytes: Slice<u8> = &s
```

### Slice Operations

```vibelang
let slice: Slice<i32> = &arr[0..3]

// Length
const len = slice.len           // 3

// Indexing
let first = slice[0]            // 1

// Iteration
for x in slice {
    println("${x}")
}

// Sub-slicing
let sub: Slice<i32> = &slice[1..2]
```

### Slice Ownership

Slices are always borrowed. They do NOT own their data:

```vibelang
fn bad() -> Slice<i32> {
    let arr: i32[3] = [1, 2, 3]
    return &arr                 // ERROR: arr dies, slice would dangle
}

fn good(arr: &i32[3]) -> Slice<i32> {
    return &arr[0..2]           // OK: caller's array outlives slice
}
```

## 4.2.5 String Literals

String literals have type `Slice<u8>` pointing to static memory:

```vibelang
const greeting: Slice<u8> = "hello"     // points to static data
let name: Slice<u8> = "world"           // also static
```

String literals:
- Are UTF-8 encoded
- Live for the entire program (static storage)
- Are immutable
- Do NOT need to be freed

### String vs Slice<u8>

| Type | Ownership | Growable | Storage |
|------|-----------|----------|---------|
| `Slice<u8>` | Borrowed | No | Points to other data |
| `String` | Owned | Yes | Heap allocated |

```vibelang
const literal: Slice<u8> = "hello"              // static, borrowed
let owned: String = String.from("hello")        // heap, owned
let view: Slice<u8> = &owned                    // borrowed from owned
```

## 4.2.6 Type Aliases

Create aliases for complex types:

```vibelang
type Tokens = Array<Token>
type ParseResult = Result<Ast, ParseError>
type Callback = fn(i32) -> bool

fn parse(src: &String) -> ParseResult {
    // ...
}
```

## 4.2.7 Nested Types

Types can be arbitrarily nested:

```vibelang
struct Compiler {
    tokens: Array<Token>
    errors: Array<Error>
    source: String
}

struct Token {
    kind: TokenKind
    lexeme: Slice<u8>           // borrows from Compiler.source
    line: u32
}

enum TokenKind {
    Ident
    Number(i64)
    String(String)              // owned string data
    Operator(Operator)
}

enum Operator {
    Plus
    Minus
    Star
    Slash
}
```

### Nested Ownership

The outermost owner is responsible for all owned nested data:

```vibelang
let compiler = Compiler {
    tokens: Array<Token>(),
    errors: Array<Error>(),
    source: String.from(read_file("input.vibe"))
}

// When compiler goes out of scope:
// 1. compiler.tokens freed (and each token's owned data)
// 2. compiler.errors freed (and each error's owned data)
// 3. compiler.source freed
// 4. compiler struct itself reclaimed
```
