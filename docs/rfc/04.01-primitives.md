# Section 4.1: Primitive Types

Primitive types map directly to LLVM types. They are the foundation upon which all other types are built.

## 4.1.1 Integer Types

### Signed Integers

| Type | Size | Range | LLVM Type |
|------|------|-------|-----------|
| `i8` | 1 byte | -128 to 127 | `i8` |
| `i16` | 2 bytes | -32,768 to 32,767 | `i16` |
| `i32` | 4 bytes | -2³¹ to 2³¹-1 | `i32` |
| `i64` | 8 bytes | -2⁶³ to 2⁶³-1 | `i64` |

### Unsigned Integers

| Type | Size | Range | LLVM Type |
|------|------|-------|-----------|
| `u8` | 1 byte | 0 to 255 | `i8` |
| `u16` | 2 bytes | 0 to 65,535 | `i16` |
| `u32` | 4 bytes | 0 to 2³²-1 | `i32` |
| `u64` | 8 bytes | 0 to 2⁶⁴-1 | `i64` |

> **Note:** LLVM uses the same `iN` type for both signed and unsigned integers. Signedness is determined by the operations performed on them.

### Integer Operations

```vibelang
let a: i32 = 10
let b: i32 = 3

// Arithmetic
let sum = a + b         // 13
let diff = a - b        // 7
let prod = a * b        // 30
let quot = a / b        // 3 (integer division)
let rem = a % b         // 1

// Comparison
let eq = a == b         // false
let lt = a < b          // false
let gt = a > b          // true

// Bitwise
let band = a & b        // 2  (0b1010 & 0b0011 = 0b0010)
let bor = a | b         // 11 (0b1010 | 0b0011 = 0b1011)
let bxor = a ^ b        // 9  (0b1010 ^ 0b0011 = 0b1001)
let bnot = ~a           // -11 (bitwise not)
let shl = a << 1        // 20
let shr = a >> 1        // 5
```

### Signed vs Unsigned Operations

The compiler emits different LLVM instructions based on signedness:

```vibelang
let s: i32 = -10
let u: u32 = 10

s / 3       // emits: sdiv (signed division)
u / 3       // emits: udiv (unsigned division)

s >> 1      // emits: ashr (arithmetic shift, preserves sign)
u >> 1      // emits: lshr (logical shift, fills with zeros)

s > 0       // emits: icmp sgt (signed greater than)
u > 0       // emits: icmp ugt (unsigned greater than)
```

### Integer Overflow

Integer overflow behavior is undefined by default, matching LLVM semantics. For checked arithmetic, use stdlib functions:

```vibelang
// Undefined behavior (may wrap, trap, or produce garbage)
let x: u8 = 255
let y = x + 1           // UB!

// Safe alternatives (stdlib)
let result = checked_add(x, 1)      // returns Option<u8>
let wrapped = wrapping_add(x, 1)    // returns 0
let saturated = saturating_add(x, 1) // returns 255
```

## 4.1.2 Floating-Point Types

| Type | Size | Precision | LLVM Type |
|------|------|-----------|-----------|
| `f32` | 4 bytes | ~7 decimal digits | `float` |
| `f64` | 8 bytes | ~15 decimal digits | `double` |

### Float Operations

```vibelang
let a: f64 = 3.14
let b: f64 = 2.0

// Arithmetic
let sum = a + b         // 5.14
let diff = a - b        // 1.14
let prod = a * b        // 6.28
let quot = a / b        // 1.57

// Comparison
let eq = a == b         // false
let lt = a < b          // false
let gt = a > b          // true

// Negation
let neg = -a            // -3.14
```

### Special Float Values

```vibelang
let inf = 1.0 / 0.0             // infinity
let neg_inf = -1.0 / 0.0        // negative infinity
let nan = 0.0 / 0.0             // NaN (not a number)

// NaN comparisons
nan == nan                       // false (NaN != NaN)
is_nan(nan)                      // true (use stdlib)
```

## 4.1.3 Boolean Type

| Type | Size | Values | LLVM Type |
|------|------|--------|-----------|
| `bool` | 1 byte | `true`, `false` | `i1` |

### Boolean Operations

```vibelang
let a = true
let b = false

// Logical operations
let and_result = a and b        // false
let or_result = a or b          // true
let not_result = not a          // false

// Short-circuit evaluation
let result = false and expensive()  // expensive() not called
let result = true or expensive()    // expensive() not called
```

### Boolean Conversions

Booleans do not implicitly convert to/from integers:

```vibelang
let b: bool = true
let x: i32 = b          // ERROR: type mismatch

// Explicit conversion
let x: i32 = if b { 1 } else { 0 }
let x: i32 = b as i32   // 1 if true, 0 if false
```

## 4.1.4 Void Type

The `void` type represents the absence of a value:

```vibelang
fn print_hello() -> void {
    print("hello")
}

// void can be omitted in return type
fn print_hello() {
    print("hello")
}
```

`void` cannot be used as a variable type:

```vibelang
let x: void = ???       // ERROR: cannot have void variable
```

## 4.1.5 Pointer Type

Raw pointers provide direct memory access:

| Type | Size | LLVM Type |
|------|------|-----------|
| `*T` | 8 bytes | `ptr` |

### Pointer Operations

```vibelang
let x: i32 = 42
let p: *i32 = &x        // take address

// Dereference
let value = *p          // 42

// Pointer arithmetic (unsafe, stdlib)
let next = ptr_add(p, 1)
let offset = ptr_diff(p, q)

// Null pointer
let null: *i32 = null_ptr()
```

### Pointer Safety

Raw pointers are inherently unsafe. The compiler does NOT enforce:
- Null checks
- Bounds checks
- Lifetime validity

For safe code, use `Slice<T>`, `Array<T>`, or references `&T`.

## 4.1.6 Fixed Array Type

Fixed arrays are inline, stack-allocated sequences:

```vibelang
let arr: i32[3] = [1, 2, 3]     // 12 bytes on stack, inline
```

| Type | Size | LLVM Type |
|------|------|-----------|
| `T[N]` | `N * sizeof(T)` | `[N x T]` |

### Fixed Array Operations

```vibelang
let arr: i32[3] = [1, 2, 3]

// Indexing
let first = arr[0]              // 1
let last = arr[2]               // 3

// Length (compile-time constant)
const len = arr.len             // 3

// Iteration
for x in arr {
    println("${x}")
}

// Slicing (creates Slice<T>)
let slice: Slice<i32> = &arr[0..2]
```

### Fixed Array Assignment

Fixed arrays of Copy types are copied on assignment:

```vibelang
let a: i32[3] = [1, 2, 3]
let b = a                       // copies all 12 bytes
a[0] = 99
print(b[0])                     // 1 (b is independent copy)
```

### Fixed Array Initialization

```vibelang
// Explicit values
let arr: i32[3] = [1, 2, 3]

// Repeated value
let zeros: i32[100] = [0; 100]

// Type inference
let arr = [1, 2, 3]             // inferred: i32[3]
let arr = [0u8; 256]            // inferred: u8[256]
```

## 4.1.7 Type Casting

Explicit casts between primitive types:

```vibelang
let x: i32 = 42

// Integer widening
let y: i64 = x as i64

// Integer narrowing (may truncate)
let z: i8 = x as i8             // 42 fits in i8

// Sign change
let u: u32 = x as u32           // reinterpret bits

// Float conversion
let f: f64 = x as f64           // 42.0

// Float to int (truncates toward zero)
let n: i32 = 3.7 as i32         // 3
let m: i32 = -3.7 as i32        // -3
```

### Cast Safety

Some casts may lose information:

```vibelang
let big: i64 = 1_000_000_000_000
let small: i32 = big as i32     // truncated! UB or wrapped value

let f: f64 = 1e100
let i: i64 = f as i64           // overflow! UB
```

For safe conversions, use stdlib functions that return `Option<T>`:

```vibelang
let result: Option<i32> = try_cast<i64, i32>(big)
match result {
    Option.Some(value) => use(value)
    Option.None => handle_overflow()
}
```

## 4.1.8 Default Values

| Type | Default |
|------|---------|
| `i8`, `i16`, `i32`, `i64` | `0` |
| `u8`, `u16`, `u32`, `u64` | `0` |
| `f32`, `f64` | `0.0` |
| `bool` | `false` |
| `*T` | `null` (if supported) |
| `T[N]` | All elements default |

> **Note:** Vibelang requires explicit initialization. There is no implicit default initialization unless using a stdlib constructor.
