# Section 4.3: Generic Types

Generics allow types and functions to be parameterized over other types.

## 4.3.1 Generic Syntax

Type parameters are enclosed in angle brackets:

```vibelang
// Generic struct
struct Pair<T, U> {
    first: T
    second: U
}

// Generic enum
enum Option<T> {
    Some(T)
    None
}

// Generic function
fn identity<T>(x: T) -> T {
    return x
}
```

## 4.3.2 Generic Structs

```vibelang
struct Vec<T> {
    ptr: *T
    len: u64
    cap: u64
}

struct Map<K, V> {
    buckets: Vec<Bucket<K, V>>
    len: u64
}

struct Bucket<K, V> {
    key: K
    value: V
    next: *Bucket<K, V>
}
```

### Instantiation

```vibelang
let ints = Vec<i32>()
let strings = Vec<String>()
let map = Map<String, i32>()
let pair = Pair<i32, String> { first: 42, second: String.from("hello") }
```

### Type Inference

When the type can be inferred, explicit parameters can be omitted:

```vibelang
let vec = Vec<i32>()
vec.push(42)                    // compiler knows T = i32

fn process(v: Vec<i32>) { }
let v = Array()                 // ERROR: can't infer T without context
```

## 4.3.3 Generic Enums

```vibelang
enum Option<T> {
    Some(T)
    None
}

enum Result<T, E> {
    Ok(T)
    Err(E)
}

enum Either<L, R> {
    Left(L)
    Right(R)
}
```

### Usage

```vibelang
fn divide(a: f64, b: f64) -> Option<f64> {
    if b == 0.0 {
        return Option.None
    }
    return Option.Some(a / b)
}

fn parse_int(s: &Slice<u8>) -> Result<i64, ParseError> {
    // ...
}
```

## 4.3.4 Generic Functions

```vibelang
fn swap<T>(a: *T, b: *T) {
    const temp = *a
    *a = *b
    *b = temp
}

fn first<T>(arr: &Slice<T>) -> Option<&T> {
    if arr.len == 0 {
        return Option.None
    }
    return Option.Some(&arr[0])
}

fn map<T, U>(arr: &Slice<T>, f: fn(&T) -> U) -> Vec<U> {
    let result = Vec<U>()
    for item in arr {
        result.push(f(item))
    }
    return result
}
```

### Calling Generic Functions

```vibelang
let a = 1
let b = 2
swap<i32>(&a, &b)               // explicit type parameter
swap(&a, &b)                    // inferred from arguments

let nums = [1, 2, 3]
let doubled = map(&nums, fn(x: &i32) -> i32 { return *x * 2 })
```

## 4.3.5 Generic Impl Blocks

```vibelang
impl<T> Vec<T> {
    fn new() -> Vec<T> {
        return Array {
            ptr: null_ptr(),
            len: 0,
            cap: 0
        }
    }
    
    fn len(self: &Vec<T>) -> u64 {
        return self.len
    }
    
    fn push(self: &Vec<T>, item: T) {
        // implementation
    }
    
    fn pop(self: &Vec<T>) -> Option<T> {
        // implementation
    }
}

impl<T> Option<T> {
    fn is_some(self: &Option<T>) -> bool {
        return match self {
            Option.Some(_) => true
            Option.None => false
        }
    }
    
    fn is_none(self: &Option<T>) -> bool {
        return not self.is_some()
    }
}
```

## 4.3.6 Fixed-Size Generic Arrays

Generics can be combined with fixed-size arrays:

```vibelang
// Dynamic array of fixed-size arrays
let matrix: Vec<f64[4]> = Vec<f64[4]>()
matrix.push([1.0, 0.0, 0.0, 0.0])
matrix.push([0.0, 1.0, 0.0, 0.0])

// Fixed-size array of generic type
struct Vec3<T> {
    data: T[3]
}

let v = Vec3<f32> { data: [1.0f32, 2.0f32, 3.0f32] }
```

### Array Size as Type Parameter

Fixed array sizes can be specified with bracket notation:

```vibelang
Vec<f64>[4]                   // fixed-size array of 4 f64
Vec<f64>[4][4]                // 4x4 matrix
Vec<Vec<i32>[3]>[2]         // 2 arrays, each containing 3 i32
```

## 4.3.7 Trait Bounds

Trait bounds constrain generic type parameters to types that implement specific traits:

```vibelang
trait Hash {
    fn hash(&self) -> u64
}

trait Eq {
    fn eq(&self, other: &Self) -> bool
}

// Single bound
fn hash_it<T: Hash>(value: &T) -> u64 {
    return value.hash()
}

// Multiple bounds on same type parameter
fn find_key<K: Hash + Eq, V>(map: &Map<K, V>, key: &K) -> Option<&V> {
    // K must implement both Hash and Eq
}
```

### Bound Syntax

Bounds are specified after the type parameter with a colon:

```vibelang
fn foo<T: Trait>(x: T)           // T must implement Trait
fn bar<T: A + B>(x: T)           // T must implement A and B
fn baz<T: A, U: B>(x: T, y: U)   // T implements A, U implements B
```

### Compile-Time Enforcement

Trait bounds are enforced at compile time during semantic analysis. If a type argument does not implement a required trait, a compile error is produced:

```vibelang
struct Point { x: i32, y: i32 }
// Point does NOT implement Hash

fn main() {
    let p = Point { x: 1, y: 2 }
    hash_it<Point>(&p)  // ERROR: type 'Point' does not implement trait 'Hash'
}
```

### Satisfying Bounds

To satisfy a bound, the type must have a trait implementation:

```vibelang
impl Hash for Point {
    fn hash(&self) -> u64 {
        return (self.x as u64) * 31 + (self.y as u64)
    }
}

fn main() {
    let p = Point { x: 1, y: 2 }
    hash_it<Point>(&p)  // OK: Point now implements Hash
}
```

### Trait Impl Validation

When implementing a trait, all required methods must be provided (unless they have default implementations):

```vibelang
trait Debug {
    fn debug(&self) -> String
}

impl Debug for Point {
    // ERROR: impl of trait 'Debug' for 'Point' is missing method 'debug'
}
```

## 4.3.8 Monomorphization

Generics are monomorphized at compile time. Each unique type instantiation generates specialized code:

```vibelang
// Source code
fn identity<T>(x: T) -> T { return x }

identity(42)            // instantiates identity<i32>
identity(3.14)          // instantiates identity<f64>
identity("hi")          // instantiates identity<Slice<u8>>
```

```llvm
; Generated LLVM IR (conceptually)
define i32 @identity_i32(i32 %x) {
    ret i32 %x
}

define double @identity_f64(double %x) {
    ret double %x
}

define { ptr, i64 } @identity_slice_u8({ ptr, i64 } %x) {
    ret { ptr, i64 } %x
}
```

### Monomorphization Trade-offs

| Advantage | Disadvantage |
|-----------|--------------|
| Zero runtime overhead | Larger binary size |
| Full optimization per type | Longer compile times |
| No vtable indirection | Code duplication |

## 4.3.9 Common Generic Patterns

### Container Types

```vibelang
Vec<T>                        // growable array
Slice<T>                        // borrowed view
Map<K, V>                       // hash map
Set<T>                          // hash set
```

### Result Types

```vibelang
Option<T>                       // nullable value
Result<T, E>                    // success or error
```

### Function Types

```vibelang
fn(T) -> U                      // function taking T, returning U
fn(&T) -> bool                  // predicate on borrowed T
fn(T, T) -> T                   // binary operation
```

### Example: Generic Algorithms

```vibelang
fn filter<T>(arr: &Slice<T>, pred: fn(&T) -> bool) -> Vec<T> {
    let result = Vec<T>()
    for item in arr {
        if pred(item) {
            result.push(item.copy())
        }
    }
    return result
}

fn fold<T, A>(arr: &Slice<T>, init: A, f: fn(A, &T) -> A) -> A {
    let acc = init
    for item in arr {
        acc = f(acc, item)
    }
    return acc
}

fn find<T>(arr: &Slice<T>, pred: fn(&T) -> bool) -> Option<&T> {
    for item in arr {
        if pred(item) {
            return Option.Some(item)
        }
    }
    return Option.None
}

// Usage
let nums = [1, 2, 3, 4, 5]
let evens = filter(&nums, fn(x: &i32) -> bool { return *x % 2 == 0 })
let sum = fold(&nums, 0, fn(acc: i32, x: &i32) -> i32 { return acc + *x })
let first_big = find(&nums, fn(x: &i32) -> bool { return *x > 3 })
```
