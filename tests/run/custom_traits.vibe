// Test custom traits on custom structs

struct Point {
    x: i64
    y: i64
}

// Custom Eq implementation
impl Eq for Point {
    fn eq(&self, other: &Point) -> bool {
        return self.x == other.x and self.y == other.y
    }
}

// Custom Ord implementation
impl Ord for Point {
    fn cmp(&self, other: &Point) -> Ordering {
        // Compare by distance from origin (x^2 + y^2)
        let self_dist = self.x * self.x + self.y * self.y
        let other_dist = other.x * other.x + other.y * other.y
        if self_dist < other_dist {
            return Ordering.Less
        }
        if self_dist > other_dist {
            return Ordering.Greater
        }
        return Ordering.Equal
    }
}

// Custom Add implementation
impl Add for Point {
    fn add(self, other: Point) -> Point {
        return Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

// Custom Mul implementation (scalar-like multiply)
impl Mul for Point {
    fn mul(self, other: Point) -> Point {
        return Point {
            x: self.x * other.x,
            y: self.y * other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 }
    let p2 = Point { x: 1, y: 2 }
    let p3 = Point { x: 3, y: 4 }

    // Test Eq (==)
    if p1 == p2 {
        println("p1 == p2: true")
    } else {
        println("p1 == p2: false")
    }

    if p1 == p3 {
        println("p1 == p3: true")
    } else {
        println("p1 == p3: false")
    }

    // Test Ord (<, >)
    // p1 distance = 1+4 = 5
    // p3 distance = 9+16 = 25
    if p1 < p3 {
        println("p1 < p3 (by distance): true")
    } else {
        println("p1 < p3 (by distance): false")
    }

    // Test Add (+)
    let p4 = p1 + p3
    println("(1,2) + (3,4) = (${p4.x}, ${p4.y})")

    // Test Mul (*)
    let p5 = Point { x: 2, y: 3 }
    let p6 = Point { x: 4, y: 5 }
    let p7 = p5 * p6
    println("(2,3) * (4,5) = (${p7.x}, ${p7.y})")

    println("All custom trait tests passed!")
}
